\chapter{Conclusiones y Trabajos Futuros}
\label{cap:conclusiones}
En esta tesis hemos investigado conceptos importantes de la tolerancia a fallas, que tienen importante aplicaciones en la práctica, como por ejemplo, en protocolos de comunicación, en vehículos autónomos, sistemas de vuelo, etc. Particularmente, nos hemos enfocado en la noción de tolerancia a fallas de forma enmascarante, esta podemos decir, es la forma de tolerancia a fallas más común en la práctica, cuando se desea que el usuario no pueda detectar la ocurrencia de la fallas. La forma más habitual para producir software que enmascara fallas es mediante la redundancia: replicación de memoria (por ejemplo varios discos, servidores, etc)  o tiempo (replicación de \textit{commits}, \textit{rollbacks}, etc.).  Sin embargo, el principal problema que se puede detectar en el área, es que en general todos estos mecanismos son aplicados de una forma \emph{ad-hoc}, y por ende, estos muchas veces carecen de un marco formal que permita estudiarlos y, también, compararlos. Este ha sido la principal motivación del presente trabajo presentar un marco formal para la tolerancia a fallas de forma enmascarante, que permita modelar una vasta cantidad de casos de estudio. Para esto hemos utilizado nociones que provienen de la teoría de juegos, la idea es modelar tolerancia a fallas mediante juegos alternantes de información perfecta con dos jugadores, en donde, uno de ellos modela el sistema tolerante a fallas, y el otro es un jugador malicioso que juega las fallas para perjudicar al sistema. La teoría de juegos nos permite modelar tanto sistemas no probabilistas como probabilistas, es importante destacar que las probabilidades aparecen naturalmente en la tolerancia a fallas, en donde, es común asociar las fallas son asociadas con alguna distribución probabilista.


Primero hemos presentado una noción de distancia de tolerancia a fallas enmascarante (o simplemente, distancia enmascarante) entre sistemas, esta se basa en una caracterización de tolerancia a fallas enmascarante a través de relaciones de simulación, y una representación correspondiente basada en juegos con objetivos cuantitativos. Estos juegos son juegos de alcanzabilidad de suma cero, jugados por dos jugadores de forma alternante. Hemos estudiado algoritmos para calcular esta distancia, bajo diferente asunciones, por ejemplo, si los sistemas son deterministas o no-deterministas. 
Creemos que muestro \textit{framework} es adecuado para apoyar a los ingenieros en el análisis y
diseño de sistemas tolerantes a fallas. Más precisamente, hemos definido una función de distancia de enmascaramiento computable tal que un ingeniero pueda medir la tolerancia enmascarante de una 
implementación tolerante a fallas determinada, es decir, el número de fallas que se pueden enmascarar antes de entrar a un estado ilegal.
De este modo, el ingeniero puede medir y comparar la distancia de tolerancia a fallas enmascarante entre implementaciones tolerantes a fallas alternativas, y seleccionar una que
se adapte mejor a sus preferencias.
Hemos desarrollado la herramienta \emph{MaskD} que permite aplicar esta distancia entre dos sistemas dados y la hemos evaluado sobre diversos casos de estudio.
En esta linea de trabajo hay muchas direcciones para el trabajo futuro. Sólo hemos definido una noción de distancia de tolerancia a fallas para enmascarar la tolerancia a fallas, nociones similares de distancia pueden definirse para otros niveles de tolerancia a fallas. Por ejemplo, el tipo de tolerancia a fallas segura ante fallos (\textit{fail-safe} en Ingles), que ante la ocurrencia de fallos garantiza que el sistema se mantendrá en estados seguros, un ejemplo de estos sistemas son los sistemas que manejan el transito en trenes, que ante la detección de trenes yendo en la dirección incorrecta, inmovilizan el transito, evitando de esta forma la posibilidad de una colisión, para modelar este tipo de tolerancia a fallas probablemente se pueden utilizar juegos cualitativos con objetivo \textit{safety}, dejamos el estudio de esto como trabajo futuro. Otro tipo de tolerancia a fallas común en la práctica, es la tolerancia a fallas del tipo no enmascarante, en este caso, ante fallas el sistema puede exhibir un comportamiento no deseado, pero se garantiza que en algún momento volverá a su comportamiento normal. Para esto se podrían utilizar objetivos cuantitativos, ya que aquí el tiempo juega un rol preponderante. Esto también se deja como trabajo futuro.

Por otro lado, también hemos investigado propiedades de juegos estocásticos con funciones de \textit{payoff} o de recompensas totales bajo la asunción de que el minimizador (es decir, el entorno) emplea solo estrategias \textit{fair} al jugar.  
Hemos demostrado que, en este escenario, se conserva la determinación (es decir, el conocimiento de la estrategia del oponente no incide en el resultado del juego) y ambos jugadores tienen estrategias óptimas sin memoria y deterministas; además, el valor del juego se puede calcular aproximando un punto fijo mayor de un operador de Bellman. Solo hemos considerado recompensas no negativas en esta tesis. Una forma posible de extender los resultados presentados aquí a juegos con recompensas negativas es adaptar las técnicas presentadas en \cite{DBLP:conf/lics/Baier0DGS18} para MDPs con costos negativos, esto tendría interesante aplicaciones ya que permitir´å considerar los casos en donde el sistema quisiera minimizar cierta recompensa, dejamos esto como un trabajo futuro.
Para mostrar la aplicabilidad de nuestra técnica, hemos presentado dos ejemplos de aplicaciones y una validación experimental sobre diversas instancias de estos casos de estudio utilizando nuestra extensión de \emph{Prism}. Creemos que los supuestos de \textit{fairness} permiten considerar un comportamiento más realista del ambiente.
No hemos investigado otras funciones comunes de \textit{payoff}, como el \textit{discounted payoff} o el \textit{limiting-average payoff}. Un beneficio de estas clases de funciones es que el valor de los juegos está bien definido incluso cuando los juegos no se detienen.
A primera vista, la noción de \textit{fairness} es poco relevante para los juegos con \textit{discounted payoff}, ya que este tipo de funciones de pago toman la mayor parte de su valor de las partes iniciales de las ejecuciones. Para el \textit{limiting-average payoff}, la situación es diferente, y las suposiciones de \textit{fairness} pueden ser relevantes, ya que podrían cambiar el valor de los juegos, dejamos esto como trabajo futuro.

Por último presentamos una relación de tolerancia a fallas enmascarante entre sistemas de transición probabilistas, acompañada por una caracterización correspondiente en términos de juegos estocásticos. A pesar de que el juego podría ser infinito, propusimos una representación simbólica finita como alternativa, esto permite que el juego pueda ser resuelto en tiempo polinomial.
%
Extendimos el juego con objetivos cuantitativos basados en contar ``hitos'' y de esta forma se puede cuantificar la tolerancia a fallas enmascarante de una implementación probabilista dada.
%
Como este juego considera objetivos de recompensa total, es necesario que haya algún criterio de terminación y por lo tanto se requiere que el juego sea casi-seguro terminante bajo \textit{fairness} del ambiente.
%
Al restringir a estrategias sin memoria, hemos demostrado que el juego resultante está determinado y que puede computarse solucionando un conjunto de ecuaciones funcionales. También proveemos una técnica para decidir si un juego es casi-seguro terminante bajo \textit{fairness} en tiempo polinomial.
%
Hay muchas direcciones para trabajo futuro. La más directa es extender estos resultados a estrategias no estacionarias. Dados los resultados presentados en el Capítulo~\ref{cap:fairAdversaries}, creemos que esto es posible pero teniendo especial cuidado con la naturaleza infinita del juego.
%
En otra dirección de trabajo, en esta tesis solo nos hemos enfocado en una versión fuerte de simulación de enmascaramiento probabilista. Para analizar sistemas complejos, es necesario contar con una versión débil de esta relación, esto permitiría abstraerse de las transiciones internas de una implementación dada. Como consecuencia de esto, se podrían considerar sistemas más complejos, ya que los protocolos de tolerancia a fallas tienen muchas veces procedimientos internos que deben abstraerse para poder componerlos con otras partes o módulos.
%
%% We are currently working on this extension, with the main goal of
%% being able to model more complex case studies.

%
Finalmente, desarrollamos la herramienta \emph{Tolerange}, la cuál implementa los algoritmos desarrollados, acompañada por una evaluación experimental sobre pequeños casos de estudio típicos. Dejamos como trabajo futuro extender esta herramienta, un problema en particular es la explosión de estados, ya que esta usa una descripción de estados explicita. Para poder mejorar su rendimiento se deben aplicar representaciones de estados símbolicas (sobre sistemas probabilistas) o mecanismos de abstracción, así poder estudiar su desempeño en casos de estudio complejos, dejamos esta línea de trabajo para un futuro.
